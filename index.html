<html>

<head>

<script src="js/parse-1.2.2.js"></script>
<script src="js/config.js"></script>
<script src="js/underscore.js"></script>
<script>

    var sp = getSpotifyApi();
    var models = sp.require("$api/models");
    var views = sp.require("$api/views");
    var playlist;
    var parse_object_href_map = {}; 
    
    window.onload = function() {

        Parse.initialize(config.appid, js_key);
           
        playlist = new models.Playlist();
        var list = new views.List(playlist);
        
        loadTracks({ 
            on: function(tracks) {
                _.each(tracks, function(parse_track) {
                    href = parse_track.attributes.href;
                    obj = {}; 
                    obj[href] = parse_track;
                    parse_object_href_map = _.extend(parse_object_href_map, obj);  
                    queue(href, playlist);  
                });
            }
         });
         
         // note: you can also customize columns by using
        var list = new views.List(playlist , function (track) {
                return new views.Track(track, 
                      //views.Track.FIELD.STAR |
                      //views.Track.FIELD.SHARE |
                      views.Track.FIELD.NAME |
                      views.Track.FIELD.ARTIST |
                      views.Track.FIELD.DURATION); //|
                      //views.Track.FIELD.ALBUM);
        });
        
        document.getElementById('playlist').appendChild(list.node); 
        
        /* Append a player */
        var multiple_tracks_player_HTML = document.getElementById('multiple-tracks-player');
        multiple_tracks_player = new views.Player();
        multiple_tracks_player.context = playlist;
        multiple_tracks_player_HTML.appendChild(multiple_tracks_player.node);
        
        models.player.observe(models.EVENT.CHANGE, function(event) {
            if (event.data.curtrack) {
                trackPlayed({ 
                    track: previousTrack(playlist, models.player.track),
                    track_map: parse_object_href_map,
                    on: function(track) {
                        console.log("Track finished playing: " + track );
                    },
                    error: function (error) {
                        console.log("An error occured. Error was not handled due to: Error handling not implemented"); 
                    }
                }); 
            } 
        }); 
    }

    var queue = function(href, playlist) {
        track = models.Track.fromURI(href);
        playlist.add(track);
    }

    var loadTracks = function(input) {
        var query = new Parse.Query("Tracks");
        query.greaterThan("votes", 0); 
        var sortByVotes = function(parse_tracks) {
            return _.clone(parse_tracks).sort(function (a,b) {
                votes_of_a = a.attributes.votes;
                votes_of_b = b.attributes.votes;
                if (a < b) return 1;
                if (b < a) return -1;
                return 0;
            });
        }

        query.find({ 
            success: function (results) {
                input.on(sortByVotes(results));
            }, 
            error: function (err) {
                if (typeof input.error === "undefined") {
                    console.log(err);
                    return;
                }
                input.error(err);
            }
        }); 
    }
    
    /**
    * @param input: Object that contains track reference, and a success and error callback function
    **/
    var trackPlayed = function(input) {
        var href = trackUri(input.track); 
        var parse_track = parse_object_href_map[href];
        parse_track.set("votes", 0);
        
        parse_track.save(null, {
            success: function(track) {
                input.on(input.track);
            },
            error: input.error
        }); 
    }

    var indexOfTrack = function(playlist, track) {
        return _.indexOf(_.map(playlist.tracks, trackUri),
                track.data.uri);
    }

    var trackUri = function(track) {
        return track.data.uri;
    }

    var previousTrack = function(playlist, current_track) {
        previousTrackIndex = Math.abs((indexOfTrack(playlist, current_track) - 1) % _.size(playlist.tracks)); 
        return playlist.tracks[previousTrackIndex];
    } 



</script> 

</head> 

<style>
.sp-item.sp-track.sp-track-availability-0{
    float: left;
    width: 100%;
}

.sp-track-field-name {
    padding-right: 5px;
}

.sp-track-field-artist {
    padding-right: 5px;
}
</style>

<body>
Hello World!

<div id="multiple-tracks-player"></div>
<div id="playlist"></div>

</body>

</html>
